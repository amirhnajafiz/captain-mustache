#!/usr/bin/env bash

############################################
############# golang mustache ##############
# welcome to golang mustache.
#
# bring your golang applications into docker
# in less than a minute.
#
#
# @author: Amirhnajafiz
# @email: najafizadeh21@gmail.com
# @year: 2020
############################################

# get username
USER_NAME_OUT="$(uname -s)"

# Verify operating system is supported...
case "${USER_NAME_OUT}" in
    Linux*)             MACHINE=linux;;
    Darwin*)            MACHINE=mac;;
    *)                  MACHINE="UNKNOWN"
esac

# check host name
if [ "$MACHINE" == "UNKNOWN" ]; then
    echo "Unsupported operating system [$(uname -s)]. Golang Mustache supports macOS, Linux, and Windows (WSL2)." >&2
    exit 1
fi

############################################
################# Colors ###################

# Reset
color_off='\033[0m'       # Text Reset
# Regular Colors
black='\033[0;30m'        # Black
red='\033[0;31m'          # Red
green='\033[0;32m'        # Green
yellow='\033[0;33m'       # Yellow
blue='\033[0;34m'         # Blue
purple='\033[0;35m'       # Purple
cyan='\033[0;36m'         # Cyan
white='\033[0;37m'        # White
# Bold
BBlack='\033[1;30m'       # Black
BRed='\033[1;31m'         # Red
BGreen='\033[1;32m'       # Green
BYellow='\033[1;33m'      # Yellow
BBlue='\033[1;34m'        # Blue
BPurple='\033[1;35m'      # Purple
BCyan='\033[1;36m'        # Cyan
BWhite='\033[1;37m'       # White
# Underline
UBlack='\033[4;30m'       # Black
URed='\033[4;31m'         # Red
UGreen='\033[4;32m'       # Green
UYellow='\033[4;33m'      # Yellow
UBlue='\033[4;34m'        # Blue
UPurple='\033[4;35m'      # Purple
UCyan='\033[4;36m'        # Cyan
UWhite='\033[4;37m'       # White
# Background
On_Black='\033[40m'       # Black
On_Red='\033[41m'         # Red
On_Green='\033[42m'       # Green
On_Yellow='\033[43m'      # Yellow
On_Blue='\033[44m'        # Blue
On_Purple='\033[45m'      # Purple
On_Cyan='\033[46m'        # Cyan
On_White='\033[47m'       # White
# High Intensity
IBlack='\033[0;90m'       # Black
IRed='\033[0;91m'         # Red
IGreen='\033[0;92m'       # Green
IYellow='\033[0;93m'      # Yellow
IBlue='\033[0;94m'        # Blue
IPurple='\033[0;95m'      # Purple
ICyan='\033[0;96m'        # Cyan
IWhite='\033[0;97m'       # White
# Bold High Intensity
BIBlack='\033[1;90m'      # Black
BIRed='\033[1;91m'        # Red
BIGreen='\033[1;92m'      # Green
BIYellow='\033[1;93m'     # Yellow
BIBlue='\033[1;94m'       # Blue
BIPurple='\033[1;95m'     # Purple
BICyan='\033[1;96m'       # Cyan
BIWhite='\033[1;97m'      # White
# High Intensity backgrounds
On_IBlack='\033[0;100m'   # Black
On_IRed='\033[0;101m'     # Red
On_IGreen='\033[0;102m'   # Green
On_IYellow='\033[0;103m'  # Yellow
On_IBlue='\033[0;104m'    # Blue
On_IPurple='\033[0;105m'  # Purple
On_ICyan='\033[0;106m'    # Cyan
On_IWhite='\033[0;107m'   # White

############################################

# Renders a text based list of options that can be selected by the
# user using up, down and enter keys and returns the chosen option.
#   Arguments   : list of options, maximum of 256
#                 "opt1" "opt2" ...
#   Return value: selected index (0 for opt1, 1 for opt2 ...)
function select_option {

    # little helpers for terminal print control and key input
    ESC=$( printf "\033")
    cursor_blink_on()  { printf "$ESC[?25h"; }
    cursor_blink_off() { printf "$ESC[?25l"; }
    cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
    print_option()     { printf "   $1 "; }
    print_selected()   { printf "  $ESC[7m $1 $ESC[27m"; }
    get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
    key_input()        { read -s -n3 key 2>/dev/null >&2
                         if [[ $key = $ESC[A ]]; then echo up;    fi
                         if [[ $key = $ESC[B ]]; then echo down;  fi
                         if [[ $key = ""     ]]; then echo enter; fi; }

    # initially print empty new lines (scroll down if at bottom of screen)
    for opt; do printf "\n"; done

    # determine current screen position for overwriting the options
    local lastrow=`get_cursor_row`
    local startrow=$(($lastrow - $#))

    # ensure cursor and input echoing back on upon a ctrl+c during read -s
    trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
    cursor_blink_off

    local selected=0
    while true; do
        # print options by overwriting the last lines
        local idx=0
        for opt; do
            cursor_to $(($startrow + $idx))
            if [ $idx -eq $selected ]; then
                print_selected "$opt"
            else
                print_option "$opt"
            fi
            ((idx++))
        done

        # user key control
        case `key_input` in
            enter) break;;
            up)    ((selected--));
                   if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
            down)  ((selected++));
                   if [ $selected -ge $# ]; then selected=0; fi;;
        esac
    done

    # cursor position back to normal
    cursor_to $lastrow
    cursor_blink_on

    return $selected
}

# Creates an option menu
function select_opt {
    select_option "$@" 1>&2
    local result=$?
    return $result
}


############################################################

# Docker commands
if [ "$#" -gt 0 ]; then
  if [ "$1" == "up" ]; then
    echo "Ship is going up ..."
    if [ "$MACHINE" == "linux" ]; then
      docker-compose up -d
    else
      docker compose up -d
    fi
    exit 0
  elif [ "$1" == "down" ]; then
    echo "Ship is going down ..."
    if [ "$MACHINE" == "linux" ]; then
      docker-compose down
    else
      docker compose down
    fi
    exit 0
  else
    echo "Fatal: unknown command $1"
    exit 1
  fi
fi

# Execute
# shellcheck disable=SC2059
printf "Welcome to ${IBlue}Golang Mustache${color_off} ...\n\n"

# Go version
printf "Which Go version do you use?\n"

# available go versions
go_version_options=("1.13" "1.14" "1.15" "1.16" "1.17" "1.18")

# get go version
select_opt "${go_version_options[@]}"
go_version_choice=$?

# shellcheck disable=SC2059
printf "\n${On_Yellow}Selected Go version:${color_off} ${green}${go_version_options[$go_version_choice]}${color_off}\n\n"

# create directory for output
WORKING_DIR="docker_out"

if [ -d "$WORKING_DIR" ]; then rm -Rf $WORKING_DIR; fi
mkdir $WORKING_DIR

# copy dockerfile based on version
DOCKER_PATH="./runtime/Dockerfile"
mkdir "$WORKING_DIR/build"
cp "$DOCKER_PATH" "$WORKING_DIR/build"

# docker version
search="{{version}}"
replace=${go_version_options[$go_version_choice]}
if [[ $search != "" && $replace != "" ]]; then
  sed -i '' "s/$search/$replace/g" "$WORKING_DIR/build/Dockerfile"
fi

# go os
printf "Which operating system?\n"

# available go OS
goos_options=("aix" "android" "darwin" "dragonfly" "freebsd" "hurd" "illumos" "ios"
              "js" "linux" "nacl" "netbsd" "openbsd" "plan9" "solaris" "windows" "zos")

# select go OS
select_opt "${goos_options[@]}"
go_os_choice=$?

# shellcheck disable=SC2059
printf "\n${On_Yellow}Selected Go OS:${color_off} ${green}${goos_options[$go_os_choice]}${color_off}\n\n"

search="{{GOOS}}"
replace=${goos_options[$go_os_choice]}
if [[ $search != "" && $replace != "" ]]; then
  sed -i '' "s/$search/$replace/g" "$WORKING_DIR/build/Dockerfile"
fi

# go arch
printf "Which architecture?\n"

# available go Arch
goarch_options=("386" "amd64" "amd64p32" "arm" "arm64" "arm64be" "armbe" "loong64"
                "mips" "mips64" "mips64le" "mips64p32" "mips64p32le" "mipsle" "ppc" "ppc64" "wasm")

# select go Arch
select_opt "${goarch_options[@]}"
goarch_choice=$?

# shellcheck disable=SC2059
printf "\n${On_Yellow}Selected Go OS:${color_off} ${green}${goarch_options[$goarch_choice]}${color_off}\n\n"

search="{{GOARCH}}"
replace=${goarch_options[$goarch_choice]}
if [[ $search != "" && $replace != "" ]]; then
  sed -i '' "s/$search/$replace/g" "$WORKING_DIR/build/Dockerfile"
fi

# managing docker compose file
DOCKER_COMPOSE="./stubs/docker-compose.yaml"
cp "$DOCKER_COMPOSE" $WORKING_DIR
DOCKER_COMPOSE="$WORKING_DIR/docker-compose.yaml"

# context
search="{{context}}"
replace="\.\/build\/"
if [[ $search != "" && $replace != "" ]]; then
  sed -i '' "s/$search/$replace/g" $DOCKER_COMPOSE
fi

# port
# shellcheck disable=SC2162
read -p "What is your application entry port: (8080) " PORT
if [[ $PORT == "" ]]; then
  PORT="8080"
fi
# shellcheck disable=SC2059
printf "\n${On_Yellow}Selected port:${color_off} ${green}${PORT}${color_off}\n\n"

search="{{port}}"
replace=$PORT
if [[ $search != "" && $replace != "" ]]; then
  sed -i '' "s/$search/$replace/g" $DOCKER_COMPOSE
fi

# others
search="{{depends}}"
replace=" "
if [[ $search != "" && $replace != "" ]]; then
  sed -i '' "s/$search/$replace/g" $DOCKER_COMPOSE
fi

search="{{services}}"
replace=" "
if [[ $search != "" && $replace != "" ]]; then
  sed -i '' "s/$search/$replace/g" $DOCKER_COMPOSE
fi

search="{{volumes}}"
replace=" "
if [[ $search != "" && $replace != "" ]]; then
  sed -i '' "s/$search/$replace/g" $DOCKER_COMPOSE
fi

############################################

# shellcheck disable=SC2059
printf "\nYour files are ready in ${BBlue}docker_out/${color_off} directory.\n\n"
printf "Copy directory files and place them next to your golang main file (which has the main package).\n"
printf "After that use the following command to start your application on docker:\n"
# shellcheck disable=SC2059
printf "\t ${IBlue}docker-compose up -d${color_off}\n"
printf "If you want to stop your application on docker, use the following command:\n"
# shellcheck disable=SC2059
printf "\t ${IBlue}docker-compose down${color_off}\n\n"
printf "Thank you for using Golang Mustache.\n"
